//
//  offer_50.swift
//  Leetcode
//
//  Created by iLeo on 2021/6/1.
//


/*
 方法一：使用哈希表存储频数
 思路与算法:
 我们可以对字符串进行两次遍历。
 在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数。在第二次遍历时，我们只要遍历到了一个只出现一次的字符，那么就返回该字符，否则在遍历结束后返回空格。

 复杂度分析:
 时间复杂度：O(n)，其中 n 是字符串 s 的长度。我们需要进行两次遍历。
 空间复杂度：O(∣Σ∣)，其中 Σ 是字符集，在本题中 s 只包含小写字母，因此 ∣Σ∣≤26。我们需要 O(∣Σ∣)的空间存储哈希映射。

 方法二：使用哈希表存储索引
 思路与算法:
 我们可以对方法一进行修改，使得第二次遍历的对象从字符串变为哈希映射。
 具体地，对于哈希映射中的每一个键值对，键表示一个字符，值表示它的首次出现的索引（如果该字符只出现一次）或者 −1（如果该字符出现多次）。当我们第一次遍历字符串时，设当前遍历到的字符为 c，如果 c 不在哈希映射中，我们就将 c 与它的索引作为一个键值对加入哈希映射中，否则我们将 c 在哈希映射中对应的值修改为 −1。
 在第一次遍历结束后，我们只需要再遍历一次哈希映射中的所有值，找出其中不为 −1 的最小值，即为第一个不重复字符的索引，然后返回该索引对应的字符。如果哈希映射中的所有值均为 −1，我们就返回空格。
 
 方法三：队列
 思路与算法:
 我们也可以借助队列找到第一个不重复的字符。队列具有「先进先出」的性质，因此很适合用来找出第一个满足某个条件的元素。
 具体地，我们使用与方法二相同的哈希映射，并且使用一个额外的队列，按照顺序存储每一个字符以及它们第一次出现的位置。当我们对字符串进行遍历时，设当前遍历到的字符为 c，如果 c 不在哈希映射中，我们就将 c 与它的索引作为一个二元组放入队尾，否则我们就需要检查队列中的元素是否都满足「只出现一次」的要求，即我们不断地根据哈希映射中存储的值（是否为 −1）选择弹出队首的元素，直到队首元素「真的」只出现了一次或者队列为空。

 在遍历完成后，如果队列为空，说明没有不重复的字符，返回空格，否则队首的元素即为第一个不重复的字符以及其索引的二元组。
 
 作者：LeetCode-Solution
 链接：https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/solution/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-by-3zqv5/
 来源：力扣（LeetCode）
 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
 */

/// 剑指 Offer 50. 第一个只出现一次的字符
/// https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/

class Solution50 {
    func firstUniqChar(_ s: String) -> Character {
        
        if s.count == 0 {
            return " "
        }
        
        var sDict = [Character:Int]()
        for item in s {
            if let temp = sDict[item] {
                sDict[item] = temp + 1
            } else {
                sDict[item] = 1
            }
        }
        for i in s {
            if let temp = sDict[i], temp == 1 {
                return i
            }
        }
        return " "
    }
}


func test50() {
    let s50 = Solution50()
    print(s50.firstUniqChar("abaccdeff"))
}
